---
title: Spherical Density in R
author: "Micah J Waldstein"
output:
  html_document:
    toc: TRUE
---

## Motivation

While there are many good reasons to be interested in spherical densities, my
interests are for densities of points on a globe.

The most common R density functions such as those from ggplot2 are based on
cartesian / euclidian coordinates. When we move to mapping, this means a few
things -

 * Global densities simply fail at the 'edge' of coordinates - e.g. near the
   poles or near +/- 180 degrees longitude
 * Projection issues. On small scales and near the equator, it is generally
   safe to make the simplification that longitude/latitude forms a square grid.
   As you look to larger scales and close to the poles, that assumption breaks
   down.

We'll be using a number of libraries:
```{r libraries}
library(ggplot2)     # For most of our plotting
library(rgdal)       # For coordinate transforms
library(sp)          # For plotting grid images
library(Directional) # For spherical density functions
library(raster)      # for projecting images
```

## The Problem

First, lets look at the problem. We'll start by generating a set of points
centered near the "edge". The details of the point generation
(`random_on_sphere`) is in the Appendix.
```{r ref.label="random_on_sphere", echo=FALSE}
```

```{r edge_points}
positions <- random_on_sphere(5000, 75, 175, 10)
positions <- data.frame(positions)
summary(positions)
library(ggplot2)
g <- ggplot(positions, aes(x = Long, y = Lat)) +
     xlim(-180, 180) + ylim(-90, 90) +
     geom_point(size = 0.5, stroke = 0, colour = "grey") +
     coord_map()
g
```

Because we're pretty far North, the points spread out across the pole. Now lets
plot densities, using both ggplot's `stat_density_2d`, a traditional cartesian
density, and the spherical density kernel from the Density package.
```{r ref.label="vmf_density_grid", echo=FALSE}
```

```{r edge_density}
densities <- vmf_density_grid(positions)
g + stat_density_2d(geom = "path") +
  geom_point(size = 0.3, stroke = 0) +
  geom_contour(data = densities, aes(x=Long, y=Lat, z=Density))
```

You can immediately see the difference - because the normal 2d density function
doesn't understand the spherical geometry, it "finds" 2 hotspots, one near
either side, while the spherical density more accurately wraps the globe. Using
a projection centered on our target center more clearly reveals the issue.

```{r edge_density_globe}
g +
  stat_density_2d(geom = "path") + geom_point(size = 0.3, stroke = 0) +
  geom_contour(data = densities, aes(x=Long, y=Lat, z=Density)) +
  coord_map("ortho", orientation = c(75, 175, 0))
```

## Heatmap

To plot a heatmap of the densities, we'll need to use the SP package.
```{r spacial_gridded_data_frame}
# We turn our densities into a list
density_matrix <- matrix(densities$Density, nrow = 100)
density_matrix <- t(apply(density_matrix, 2, rev))
gridVals <- data.frame(att=as.vector(density_matrix))
gt <- GridTopology(cellcentre.offset = c(-178.2, -89.1),
                   cellsize = c( 360 / 100, 180 / 100),
                   cells.dim = c(100, 100))
sGDF <- SpatialGridDataFrame(gt, data = gridVals)

# Categorize
breaks <- pretty(gridVals$att, 50)
sGDF$indexToPlot <- cut(gridVals$att, breaks, include.lowest = F, labels = F)
plot(sGDF["indexToPlot"])
```

```{r raster_proj}
r <- raster(sGDF, layer = 2)
projection(r) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84")
plot(r)
# new.proj <- "+proj=lcc +lat_1=48 +lat_2=33 +lon_0=-100 +ellps=WGS84"

#r.proj <- projectRaster(r, crs = new.proj, method = "ngb")
#plot(r.proj)
```

```{r raster_proj_adj}
#pol <- rasterToPolygons(r, fun=function(x){x>1})
pol <- rasterToPolygons(r)
grid.lines <- gridlines(pol,
                        easts = pretty(bbox(pol)[1,], 10),
                        norths = pretty(bbox(pol)[2,], 10))
color_vals <- rev(heat.colors(50))
#plot(pol, col=color_vals[r[r>1]], border = "transparent")
plot(pol, col=color_vals[r[]], border = "transparent")
plot(grid.lines, add=TRUE, lty=2)

new.proj <- CRS("+proj=wintri")
pol.proj = spTransform(pol, new.proj)
grid.proj <- spTransform(grid.lines, new.proj)
plot(pol.proj, col=color_vals[r[]], border = "transparent")
plot(grid.proj, add=TRUE, lty=2)

centered.proj <- CRS("+proj=laea +y_0=0 +lon_0=175 +lat_0=75 +ellps=WGS84 +no_defs")
pol.proj = spTransform(pol, centered.proj)
grid.proj <- spTransform(grid.lines, centered.proj)
plot(pol.proj, col=color_vals[r[]], border = "transparent")
plot(grid.proj, add=TRUE, lty=2)
```

```{r raster_contour}
r <- raster(sGDF, layer = 1)
projection(r) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84")
contours <- rasterToContour(r, nlevels = 5)
contours.proj <- spTransform(contours, CRS("+proj=wintri"))
plot(contours.proj)

filled_contours <- lapply(contours@lines, function(cont) {
                            c.line <- lapply(seq_along(cont@Lines), function(i) {
                              coords <- cont@Lines[[i]]@coords
                              if (i > 1) {
                                pts <- coords[c(1, nrow(coords)), ]
                                last <- cont@Lines[[i - 1]]@coords
                                last <- last[nrow(last),]
                                dists <- spDistsN1(pts, last, longlat = TRUE)
                                if (dists[2] < dists[1]) {
                                  coords <- apply(coords, 2, rev)
                                }
                              }
                              coords
                            })
                            Polygons(list(Polygon(do.call(rbind, c.line), hole = F)),
                                     paste0(cont@ID, "_poly"))
                        })

filled_contours <- SpatialPolygons(filled_contours)
projection(filled_contours) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84")
plot(filled_contours, col=rev(heat.colors(5)))
filled_contours.proj <- spTransform(filled_contours, CRS("+proj=longlat +lon_wrap=180"))
plot(filled_contours.proj, col=rev(heat.colors(5)), border = "transparent")

```



## Simple Example & Explanation

Single blob on a sphere


## Practical #1

Canadian population density (projection) from census

## Practical #2

Earthquake density (wrapping of edges!)
https://www.r-bloggers.com/circular-or-spherical-data-and-density-estimation/

## Appendix

### References

 * [RWorldMap](https://github.com/AndySouth/rworldmap) - Particularly for getting me started on how to plot gridded data
 * [Spatial data in R: Using R as a GIS](https://pakillo.github.io/R-GIS-tutorial/) - how to reproject gridded data via rasters
 * [coord_proj](http://rpubs.com/hrbrmstr/coord-proj) - Source of projections
   to steal


### Random Points on Sphere


```{r random_on_sphere}
random_on_sphere <- function(n, lat, lon, concentration) {
  # Dircectional defines lat + long as 0-180 and 0-360 respectively so we have
  # shift back and forth
  mu <- euclid(c(lat + 90, lon + 180))[1,]
  pts <- euclid.inv(rvmf(n, mu, concentration))
  pts[,1] <- pts[,1] - 90
  pts[,2] <- pts[,2] - 180
  pts
}
```

### Spherical Density Function

This calculates a grid of densities which can then be used with `geom_contour`.
The code basically comes directly from [Directional's
vmf.kerncontour](https://rdrr.io/cran/Directional/man/vmf.kerncontour.html),
only returning a data.frame instead of actually plotting the output.

```{r vmf_density_grid}
vmf.kerncontour.mjw <- function(u, thumb = "none", ret.all = FALSE, full = FALSE,
                            ngrid = 100) {
  ## u contains the data in latitude and longitude
  ## the first column is the latitude and the
  ## second column is the longitude
  ## thumb is either 'none' (defualt), or 'rot' (Garcia-Portugues, 2013)
  ## ret.all if set to TRUE returns a matrix with latitude, longitude and density
  ## full if set to TRUE calculates densities for the full sphere, otherwise
  ##   using extents of the data
  ## ngrid specifies the number of points taken at each axis
  n <- dim(u)[1]  ## sample size
  x <- euclid(u)

  if (thumb == "none") {
    h <- as.numeric( vmfkde.tune(x, low = 0.1, up = 1)[1] )
  } else if (thumb == "rot") {
    k <- vmf(x)$kappa
    h <- ( (8 * sinh(k)^2) / (k * n * ( (1 + 4 * k^2) * sinh(2 * k) -
    2 * k * cosh(2 * k)) ) ) ^ ( 1/6 )
  }

  if (full) {
    x1 <- seq( 0, 180, length = ngrid )  ## latitude
    x2 <- seq( 0, 360, length = ngrid )  ## longitude
  } else {
    x1 <- seq( min(u[, 1]) - 5, max(u[, 1]) + 5, length = ngrid )  ## latitude
    x2 <- seq( min(u[, 2]) - 5, max(u[, 2]) + 5, length = ngrid )  ## longitude
  }
  cpk <- 1 / (  ( h^2)^0.5 *(2 * pi)^1.5 * besselI(1/h^2, 0.5) )
  mat <- matrix(nrow = ngrid, ncol = ngrid)

  for (i in 1:ngrid) {
    for (j in 1:ngrid) {
      y <- euclid( c(x1[i], x2[j]) )
      a <- as.vector( tcrossprod(x, y / h^2) )
      can <- sum( exp(a + log(cpk)) ) / ngrid
      if (abs(can) < Inf)   mat[i, j] <- can
    }
  }

  if (ret.all) {
    return(list(Lat = x1, Long = x2, h = h, d = mat))
  } else {
    contour(mat$Lat, mat$Long, mat, nlevels = 10, col = 2, xlab = "Latitude",
            ylab = "Longitude")
    points(u[, 1], u[, 2])
  }
}

vmf_density_grid <- function(u, ngrid = 100) {
  u[,1] <- u[,1] + 90
  u[,2] <- u[,2] + 180
  res <- vmf.kerncontour.mjw(u, thumb = "rot", ret.all = T, full = T)

  ret <- expand.grid(Lat = res$Lat - 90, Long = res$Long - 180)
  ret$Density = c(res$d)
  ret
}
```

